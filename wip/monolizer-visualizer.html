<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monolizer - Advanced 2D Visualization</title>

    <style>
      :root {
        /* Light mode colors */
        --background-color: #e1e5e6;
        --text-color: #000;
        --plugin-bg-color: #e0e0e0;
        --box-shadow-color1: #bebebe;
        --box-shadow-color2: #ffffff;
        --logo-color: #2a2a2a;
        --visualizer-inset-shadow1: #bebebe;
        --visualizer-inset-shadow2: #ffffff;
        --knob-bg-color: #e0e0e0;
        --knob-center-color: #00a7b6;
        --action-color: #ec5e6c;
        --value-color: #555;
        --footer-color: #777;
      }

      [data-theme="dark"] {
        /* Dark mode colors */
        --background-color: #121212;
        --text-color: white;
        --plugin-bg-color: #1e1e1e;
        --box-shadow-color1: #0f0f0f;
        --box-shadow-color2: #151515;
        --logo-color: #f0f0f0;
        --visualizer-inset-shadow1: #0f0f0f;
        --visualizer-inset-shadow2: #151515;
        --knob-bg-color: #2e2e2e;
        --knob-center-color: #5ff2ff;
        --action-color: #ec5e6c;
        --value-color: #cccccc;
        --footer-color: #999;
      }

      body {
        font-family: "Helvetica Neue", Helvetica, Inter, system-ui, Avenir, Arial, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        user-select: none;
      }

      .plugin-container {
        position: relative;
        background-color: var(--plugin-bg-color);
        width: 600px;
        padding: 30px;
        border-radius: 20px;
        box-shadow:
          20px 20px 60px var(--box-shadow-color1),
          -20px -20px 60px var(--box-shadow-color2);
      }

      .header {
        text-align: center;
        margin-bottom: 20px;
      }

      .logo {
        font-size: 2em;
        font-weight: bold;
        color: var(--logo-color);
      }

      .visualizer-container {
        position: relative;
        margin-top: 20px;
        margin-bottom: 20px;
        border-radius: 10px;
        overflow: hidden;
        box-shadow:
          inset 5px 5px 10px var(--visualizer-inset-shadow1),
          inset -5px -5px 10px var(--visualizer-inset-shadow2);
      }

      #visualizer {
        background-color: #111;
        width: 100%;
      }

      .controls {
        display: flex;
        justify-content: space-around;
        align-items: flex-start;
      }

      .knob-container {
        text-align: center;
      }

      .knob-wrapper {
        position: relative;
        border-radius: 50%;
        overflow: hidden;
        width: 100px;
        height: 100px;
        margin: 0 auto 10px;
        box-shadow:
          10px 10px 20px var(--box-shadow-color1),
          -10px -10px 20px var(--box-shadow-color2);
      }

      .knob {
        width: 100px;
        height: 100px;
        background-color: var(--knob-bg-color);
        border-radius: 50%;
        position: relative;
        cursor: pointer;
      }

      .knob::after {
        content: "";
        position: absolute;
        top: 1px;
        left: 50%;
        width: 6px;
        height: 30px;
        background-color: var(--knob-center-color);
        border-radius: 6px;
        transform: translateX(-50%);
      }

      .knob-label {
        font-size: 1em;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .value {
        font-size: 0.9em;
        color: var(--value-color);
      }

      .footer {
        margin-top: 20px;
        text-align: center;
        font-size: 0.8em;
        color: var(--footer-color);
      }

      #toggle-theme {
        position: fixed;
        top: 20px;
        right: 20px;
      }

      #stop {
        font-weight: bold;
        color: var(--background-color);
        background: #ec5e6c;
        text-transform: uppercase;
      }

      .button {
        color: var(--text-color);
        border: none;
        font-size: 14px;
        padding: 10px 20px;
        border-radius: 6px;
        background: var(--plugin-bg-color);
        box-shadow:
          20px 20px 60px var(--box-shadow-color1),
          -20px -20px 60px var(--box-shadow-color2);
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <button id="toggle-theme" class="button">Theme: <span style="font-weight: bold"></span></button>

    <script>
      document.getElementById("toggle-theme").addEventListener("click", swapTheme);

      function swapTheme() {
        const themes = ["light", "dark"];

        const currentIndex = themes.indexOf(document.body.dataset.theme);
        const nextIndex = (currentIndex + 1) % themes.length;
        document.body.dataset.theme = themes[nextIndex];

        document.getElementById("toggle-theme").querySelector("span").textContent = document.body.dataset.theme;
      }

      swapTheme();
    </script>

    <div class="plugin-container">
      <div class="header">
        <div class="logo">Monolizer</div>
      </div>
      <div class="visualizer-container">
        <canvas id="visualizer" width="1800" height="1400"></canvas>
      </div>
      <div class="controls">
        <div class="knob-container">
          <div class="knob-wrapper">
            <div class="knob" id="freqKnob"></div>
          </div>

          <div class="knob-label">FREQ</div>
          <div class="value" id="freqValue">300 Hz</div>
        </div>
        <div class="knob-container">
          <div class="knob-wrapper">
            <div class="knob" id="kneeKnob"></div>
          </div>

          <div class="knob-label">KNEE</div>
          <div class="value" id="kneeValue">0.5</div>
        </div>
        <div class="knob-container">
          <div class="knob-wrapper">
            <div class="knob" id="mixKnob"></div>
          </div>

          <div class="knob-label">MIX</div>
          <div class="value" id="mixValue">100%</div>
        </div>
      </div>

      <div style="margin: 20px auto; display: flex; align-items: center; justify-content: center">
        <button id="stop" class="button button-red">Panic!</button>
      </div>
      <div class="footer">Monolizer v1.0 - Turn your bass mono!</div>
    </div>

    <script>
      const canvas = document.getElementById("visualizer");
      const ctx = canvas.getContext("2d");
      const particles = [];
      const frequencyLabels = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000];

      // Params
      let freq = 4000;
      let knee = 0.5;
      let mix = 100;

      // Audio generator
      let audioCtx;
      let bufferLength;
      let analyserLeft;
      let analyserRight;
      let dataArrayLeft;
      let dataArrayRight;

      // Scale factor
      const SCALE_FACTOR = 2;

      // Scaled dimensions
      const PARTICLE_SIZE = 2;

      // Stereo width lines
      const STEREO_MARGIN = 20;
      const BAND_SPACING = 0;

      const MIN_FREQ = 20;
      const MAX_FREQ = 10000;

      // Set actual size in memory (scaled up)
      const CANVAS_WIDTH = 1600;
      const CANVAS_HEIGHT = 800;

      const SCALED_WIDTH = CANVAS_WIDTH / SCALE_FACTOR;
      const SCALED_HEIGHT = CANVAS_HEIGHT / SCALE_FACTOR;

      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;

      // Set display size (scaled down)
      canvas.style.width = `${CANVAS_WIDTH / 2}px`;
      canvas.style.height = `${CANVAS_HEIGHT / 2}px`;

      // Scale everything down
      ctx.scale(SCALE_FACTOR, SCALE_FACTOR);

      function init() {
        createSoundGenerator();

        for (let i = 0; i < 1000; i++) {
          particles.push({
            x: Math.random() * SCALED_WIDTH,
            y: Math.random() * (SCALED_HEIGHT - 2 * STEREO_MARGIN) + STEREO_MARGIN,
            size: Math.random() * PARTICLE_SIZE + 1,
            speedX: (Math.random() - 0.5) * 2,
            speedY: (Math.random() - 0.5) * 2.5,
          });
        }
        animate();
      }

      const createOscillator = (type, frequency) => {
        const oscillator = audioCtx.createOscillator();
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime); // initial frequency
        return oscillator;
      };

      const createNoise = () => {
        const noise = audioCtx.createBufferSource();
        const bufferSize = audioCtx.sampleRate * 2;
        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        noise.buffer = noiseBuffer;
        noise.loop = true;
        return noise;
      };

      function createSoundGenerator() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0.01, audioCtx.currentTime);

        // Create a lowpass filter node
        const lowpassFilter = audioCtx.createBiquadFilter();
        lowpassFilter.type = "lowpass";
        lowpassFilter.frequency.setValueAtTime(freq, audioCtx.currentTime);

        // Create a panner node
        const panner = audioCtx.createStereoPanner();
        panner.pan.setValueAtTime(0, audioCtx.currentTime);

        const oscillators = [
          createOscillator("square", 1000),
          createOscillator("square", 500),
          createOscillator("square", 250),
        ];

        const noise = createNoise();

        oscillators.forEach((osc) => osc.connect(gainNode));
        noise.connect(gainNode);
        gainNode.connect(lowpassFilter);
        lowpassFilter.connect(panner);

        // Split the audio signal
        splitter = audioCtx.createChannelSplitter(2);
        panner.connect(splitter);

        // Create analyzers for left and right channels
        analyserLeft = audioCtx.createAnalyser();
        analyserRight = audioCtx.createAnalyser();
        analyserLeft.fftSize = 128;
        analyserRight.fftSize = 128;

        bufferLength = analyserLeft.fftSize;
        dataArrayLeft = new Uint8Array(bufferLength);
        dataArrayRight = new Uint8Array(bufferLength);

        splitter.connect(analyserLeft, 0);
        splitter.connect(analyserRight, 1);

        // Connect to the destination
        splitter.connect(audioCtx.destination);

        console.log("Audio context created");

        oscillators.forEach((osc) => osc.start());
        noise.start();

        // Randomize the oscillator frequency every second
        setInterval(() => {
          const notes = [
            261.63, 293.66, 329.63, 349.23, 392.0, 440.0, 493.88, 523.25, 1046.5, 1108.73, 1174.66, 1244.51, 1318.51,
            1479.98, 1567.98, 1661.22, 1760.0, 1864.66, 1975.53,
          ];

          oscillators.forEach((osc) => {
            const randomNote = notes[Math.floor(Math.random() * notes.length)];
            osc.frequency.setValueAtTime(randomNote, audioCtx.currentTime);
          });
        }, 400);

        setInterval(() => {
          const freqs = [
            1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700,
            2800, 2900, 3000, 3100, 3200, 3300, 3400, 3500, 3600, 3700, 3800, 3900, 4000, 4100, 4200, 4300, 4400, 4500,
            4600, 4700, 4800, 4900, 5000, 5100, 5200, 5300, 5400, 5500, 5600, 5700, 5800, 5900, 6000, 6100, 6200, 6300,
            6400, 6500, 6600, 6700, 6800, 6900, 7000, 7100, 7200, 7300, 7400, 7500, 7600, 7700, 7800, 7900, 8000, 8100,
          ];
          const randomHz = freqs[Math.floor(Math.random() * freqs.length)];
          lowpassFilter.frequency.linearRampToValueAtTime(randomHz, audioCtx.currentTime + 0.5);
        }, 50);

        setInterval(() => {
          const randomPan = Math.random() * 2 - 1;
          panner.pan.setValueAtTime(randomPan + -0.01, audioCtx.currentTime);
        }, 500);
      }

      function drawStereoSpectrum() {
        ctx.save();
        analyserLeft.getByteFrequencyData(dataArrayLeft);
        analyserRight.getByteFrequencyData(dataArrayRight);

        ctx.clearRect(0, 0, SCALED_WIDTH, SCALED_HEIGHT);

        const barWidth = SCALED_WIDTH / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const leftBarHeight = (dataArrayLeft[i] / 255) * (SCALED_HEIGHT / 2 - STEREO_MARGIN);
          const rightBarHeight = (dataArrayRight[i] / 255) * (SCALED_HEIGHT / 2 - STEREO_MARGIN);

          // Exaggerate the bar heights
          const exaggerationFactor = 2.5;
          const exaggeratedLeftHeight = Math.min(leftBarHeight * exaggerationFactor, SCALED_HEIGHT / 2 - STEREO_MARGIN);
          const exaggeratedRightHeight = Math.min(
            rightBarHeight * exaggerationFactor,
            SCALED_HEIGHT / 2 - STEREO_MARGIN,
          );

          // Create gradient for left channel
          const leftGradient = ctx.createLinearGradient(
            x,
            SCALED_HEIGHT / 2,
            x,
            SCALED_HEIGHT / 2 - exaggeratedLeftHeight,
          );
          leftGradient.addColorStop(0, "rgba(255, 0, 0, 0.8)");
          leftGradient.addColorStop(0.5, "rgba(255, 255, 0, 0.8)");
          leftGradient.addColorStop(1, "rgba(0, 255, 0, 0.1)");

          // Create gradient for right channel
          const rightGradient = ctx.createLinearGradient(
            x,
            SCALED_HEIGHT / 2,
            x,
            SCALED_HEIGHT / 2 + exaggeratedRightHeight,
          );
          rightGradient.addColorStop(0, "rgba(255, 0, 0, 0.8)");
          rightGradient.addColorStop(0.5, "rgba(255, 255, 0, 0.8)");
          rightGradient.addColorStop(1, "rgba(0, 255, 0, 0.1)");

          // Draw left channel bar
          ctx.fillStyle = leftGradient;
          ctx.fillRect(x, SCALED_HEIGHT / 2 - exaggeratedLeftHeight, barWidth, exaggeratedLeftHeight);

          // Draw right channel bar
          ctx.fillStyle = rightGradient;
          ctx.fillRect(x, SCALED_HEIGHT / 2, barWidth, exaggeratedRightHeight);

          // Add glow effect
          // ctx.shadowBlur = 1;
          // ctx.shadowColor = "rgba(255, 255, 255, 0.5)";

          x += barWidth + 10; // Add a small gap between bars
        }

        // Draw center line
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, SCALED_HEIGHT / 2);
        ctx.lineTo(SCALED_WIDTH, SCALED_HEIGHT / 2);
        ctx.stroke();

        ctx.restore();
      }

      function animate() {
        ctx.clearRect(0, 0, SCALED_WIDTH, SCALED_HEIGHT);
        drawBackground();
        drawStereoSpectrum();
        updateAndDrawParticles();
        drawCutoffLine();
        requestAnimationFrame(animate);
      }

      function drawBackground() {
        ctx.save();
        const format = (hz) => (hz >= 1000 ? `${hz / 1000} kHz` : `${hz} Hz`);

        ctx.fillStyle = "#ccc";
        ctx.font = "8px sans-serif";

        // Draw frequency labels
        frequencyLabels.forEach((hz) => {
          ctx.save();
          const x = toCanvasX(hz);

          // Draw tick
          ctx.strokeStyle = "#222";
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, SCALED_HEIGHT - STEREO_MARGIN);
          ctx.stroke();

          ctx.translate(x, SCALED_HEIGHT - 5);
          ctx.fillStyle = "#555";
          ctx.textAlign = "center";
          ctx.fillText(format(hz), 0, 0);
          ctx.restore();
        });

        // Draw frequency bands
        const bands = [
          { label: "Sub", from: 20, to: 60, show: false },
          { label: "Bass", from: 60, to: 250, show: false },
          { label: "Low Mid", from: 250, to: 500, show: false },
          { label: "Mid", from: 500, to: 2000 },
          { label: "High Mid", from: 2000, to: 6000 },
          { label: "Presence", from: 6000, to: 12000 },
          { label: "Treble", from: 12000, to: 20000, show: false },
        ];

        bands.forEach((band) => {
          // return; // TODO: disable
          // Skip bands that are not shown
          if (band.show === false) return;

          ctx.save();
          const fromX = toCanvasX(band.from);
          const toX = toCanvasX(band.to);

          // Draw band background
          ctx.strokeStyle = "#555";
          ctx.fillStyle = "transparent";
          ctx.fillStyle = "#333";
          ctx.fillRect(fromX, SCALED_HEIGHT - STEREO_MARGIN, toX - fromX - BAND_SPACING, STEREO_MARGIN / 2);

          // Draw band border/stroke
          // ctx.strokeStyle = "#555";
          ctx.lineWidth = 1;
          ctx.strokeRect(fromX, SCALED_HEIGHT - STEREO_MARGIN, toX - fromX - BAND_SPACING, STEREO_MARGIN / 2);

          // Draw band label

          ctx.fillStyle = "white";
          ctx.font = "10px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(
            band.label,
            fromX + (toX - fromX - BAND_SPACING) / 2,
            SCALED_HEIGHT - STEREO_MARGIN + STEREO_MARGIN / 4 + 5,
          );

          ctx.restore();
        });

        // Draw stereo width lines
        ctx.strokeStyle = "#8a8a8a";
        ctx.beginPath();
        ctx.moveTo(0, STEREO_MARGIN);
        ctx.lineTo(SCALED_WIDTH, STEREO_MARGIN);
        ctx.moveTo(0, SCALED_HEIGHT - STEREO_MARGIN);
        ctx.lineTo(SCALED_WIDTH, SCALED_HEIGHT - STEREO_MARGIN);
        ctx.stroke();

        ctx.restore();
      }

      function updateAndDrawParticles() {
        const cutoffX = toCanvasX(freq);
        const kneeWidth = (knee * SCALED_WIDTH) / 16;

        ctx.fillStyle = `rgba(95, 242, 255, ${mix / 100})`;
        // ctx.fillStyle = `white`;
        particles.forEach((p) => {
          p.x += p.speedX;
          p.y += p.speedY;

          if (p.x < 0 || p.x > SCALED_WIDTH) p.speedX *= -1;
          if (p.y < STEREO_MARGIN || p.y > SCALED_HEIGHT - STEREO_MARGIN) p.speedY *= -1;

          p.x = Math.max(0, Math.min(SCALED_WIDTH, p.x));
          p.y = Math.max(STEREO_MARGIN, Math.min(SCALED_HEIGHT - STEREO_MARGIN, p.y));

          let size = p.size;
          if (p.x < cutoffX) {
            const distFromCutoff = cutoffX - p.x;
            const kneeEffect = Math.min(1, distFromCutoff / kneeWidth);
            const centerY = SCALED_HEIGHT / 2;
            p.y = centerY + (p.y - centerY) * (1 - kneeEffect) * 0.2;
            size *= 1 - kneeEffect * 0.5;
            p.speedY *= kneeEffect;
          }

          // Draw particle circle
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function logScale(value) {
        const minp = Math.log(MIN_FREQ);
        const maxp = Math.log(MAX_FREQ);
        const minv = Math.log(20);
        const maxv = Math.log(20000);

        const scale = (maxv - minv) / (maxp - minp);
        return Math.exp(minv + scale * (Math.log(value) - minp));
      }

      function drawCutoffLine() {
        ctx.save();
        const cutoffX = toCanvasX(freq);

        // Draw cutoff line
        ctx.strokeStyle = "var(--action-color)";
        ctx.beginPath();
        ctx.moveTo(cutoffX, STEREO_MARGIN);
        ctx.lineTo(cutoffX, SCALED_HEIGHT - STEREO_MARGIN);
        ctx.stroke();

        // Draw knee area
        const kneeWidth = (knee * SCALED_WIDTH) / 2;

        const controlPointX = cutoffX - kneeWidth;
        const controlPointY = SCALED_HEIGHT / 2;

        // debug, draw control point
        // ctx.fillStyle = "#bf5fff";
        // ctx.fillRect(controlPointX - 8, controlPointY - 8, 16, 16);

        ctx.strokeStyle = "rgba(95, 242, 255, 0.5)";
        ctx.beginPath();
        ctx.moveTo(Math.max(0, cutoffX - kneeWidth), SCALED_HEIGHT / 2);
        ctx.quadraticCurveTo(controlPointX, controlPointY, cutoffX, STEREO_MARGIN);
        ctx.lineTo(cutoffX, SCALED_HEIGHT - STEREO_MARGIN);
        ctx.quadraticCurveTo(controlPointX, controlPointY, Math.max(0, cutoffX - kneeWidth), SCALED_HEIGHT / 2);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }

      function toCanvasX(originalX) {
        return ((originalX - MIN_FREQ) * SCALED_WIDTH) / (MAX_FREQ - MIN_FREQ);
      }

      function scale(value, inMin, inMax, outMin, outMax) {
        return outMin + ((value - inMin) * (outMax - outMin)) / (inMax - inMin);
      }

      // document.getElementById("freq").addEventListener("input", (e) => {
      //   freq = parseFloat(e.target.value);
      //   document.getElementById("freqValue").textContent = Math.round(freq);
      // });
      //
      // document.getElementById("knee").addEventListener("input", (e) => {
      //   knee = parseFloat(e.target.value);
      //   document.getElementById("kneeValue").textContent = knee.toFixed(2);
      // });
      //
      // document.getElementById("mix").addEventListener("input", (e) => {
      //   mix = parseFloat(e.target.value);
      //   document.getElementById("mixValue").textContent = mix;
      // });

      document.addEventListener("mousemove", init, { once: true });
      document.addEventListener("mousemove", () => {
        if (audioCtx) audioCtx.resume();
      });

      document.getElementById("stop").addEventListener("click", () => {
        audioCtx.close();
      });

      /// NEW STUF ---------------------------------------
      // Knob interaction logic
      const freqKnob = document.getElementById("freqKnob");
      const kneeKnob = document.getElementById("kneeKnob");
      const mixKnob = document.getElementById("mixKnob");
      const freqValue = document.getElementById("freqValue");
      const kneeValue = document.getElementById("kneeValue");
      const mixValue = document.getElementById("mixValue");

      function updateKnob(knob, value, maxValue) {
        const angle = (value / maxValue) * 360 - 180;
        knob.style.transform = `rotate(${angle}deg)`;
      }

      freqKnob.addEventListener("mousedown", function (event) {
        document.addEventListener("mousemove", moveFreq);
        document.addEventListener("mouseup", stopMoving);
      });

      kneeKnob.addEventListener("mousedown", function (event) {
        document.addEventListener("mousemove", moveKnee);
        document.addEventListener("mouseup", stopMoving);
      });

      mixKnob.addEventListener("mousedown", function (event) {
        document.addEventListener("mousemove", moveMix);
        document.addEventListener("mouseup", stopMoving);
      });

      function moveFreq(event) {
        const rect = freqKnob.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const angle = Math.atan2(event.clientY - centerY, event.clientX - centerX);
        freq = Math.max(20, Math.min(MAX_FREQ, Math.round(((angle + Math.PI) / (2 * Math.PI)) * MAX_FREQ)));
        freqValue.textContent = `${freq} Hz`;
        updateKnob(freqKnob, freq, MAX_FREQ);
      }

      function moveKnee(event) {
        const rect = kneeKnob.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const angle = Math.atan2(event.clientY - centerY, event.clientX - centerX);
        knee = Math.max(0, Math.min(1, ((angle + Math.PI) / (2 * Math.PI)).toFixed(2)));
        kneeValue.textContent = knee;
        updateKnob(kneeKnob, knee, 1);
      }

      function moveMix(event) {
        const rect = mixKnob.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const angle = Math.atan2(event.clientY - centerY, event.clientX - centerX);
        mix = Math.max(0, Math.min(100, Math.round(((angle + Math.PI) / (2 * Math.PI)) * 100)));
        mixValue.textContent = `${mix}%`;
        updateKnob(mixKnob, mix, 100);
      }

      function stopMoving() {
        document.removeEventListener("mousemove", moveFreq);
        document.removeEventListener("mousemove", moveKnee);
        document.removeEventListener("mousemove", moveMix);
      }
    </script>
  </body>
</html>
